import fs from "fs/promises";
import path from "path";
import fse from "fs-extra";
import * as uuid from "uuid";
import { runFFmpeg } from "../utils/ffmpeg.js";
import { PlanInput, PlanInputSchema, JobStatus } from "../types/plan.js";
import { buildSlidesVideo } from "./ConcatPlanBuilder.js";
import { resolveVoiceTrack } from "../audio/TTSService.js";
import { transcribeWithWhisper } from "../transcribe/Whisper.js";
import { buildAudioFilter } from "../audio/AudioMixer.js";
import { buildVideoOverlayFilter } from "./OverlayRenderer.js";
import { log } from "../logger.js";

const uuidv4 = uuid.v4;

type QueueItem = { id: string; input: PlanInput };

export default class MediaCreator {
  private queue: QueueItem[] = [];
  private running = false;
  private statuses = new Map<string, JobStatus>();
  private completed = new Map<string, JobStatus>();
  private cancelled = new Set<string>();

  /** –∫–æ–ª–±—ç–∫ –¥–ª—è SSE */
  public onStatus?: (status: JobStatus) => void;

  enqueueJob(input: PlanInput) { return this.enqueue(input); }
  getJobStatus(id: string) { return this.statuses.get(id) || this.completed.get(id); }
  
  // –ù–æ–≤—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è API
  getAllJobs(limit = 20, offset = 0) {
    const all = Array.from(this.statuses.values()).concat(Array.from(this.completed.values()));
    const sorted = all.sort((a, b) => (b as any).createdAt || 0 - (a as any).createdAt || 0);
    const total = sorted.length;
    return {
      jobs: sorted.slice(offset, offset + limit),
      pagination: { limit, offset, total, hasMore: offset + limit < total }
    };
  }

  cancelJob(id: string) {
    if (!this.statuses.has(id)) {
      return false;
    }
    this.cancelled.add(id);
    return true;
  }

  enqueue(input: PlanInput) {
    const parsed = PlanInputSchema.parse(input);
    const id = uuidv4();
    const status: JobStatus & { createdAt: number } = { 
      id, 
      state: "queued", 
      progress: 0,
      createdAt: Date.now()
    };
    this.statuses.set(id, status);
    this.onStatus?.(status);
    this.queue.push({ id, input: parsed });
    this.pump();
    return id;
  }

  private async pump() {
    if (this.running) return;
    const item = this.queue.shift();
    if (!item) return;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–º–µ–Ω—É –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –æ–±—Ä–∞–±–æ—Ç–∫–∏
    if (this.cancelled.has(item.id)) {
      this.cancelled.delete(item.id);
      this.statuses.delete(item.id);
      this.running = false;
      this.pump();
      return;
    }
    
    this.running = true;
    try {
      let status: JobStatus & { createdAt: number } = { 
        id: item.id, 
        state: "running", 
        progress: 0, 
        message: "init",
        createdAt: Date.now()
      };
      this.statuses.set(item.id, status);
      this.onStatus?.(status);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–º–µ–Ω—É –≤–æ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
      if (this.cancelled.has(item.id)) {
        this.cancelled.delete(item.id);
        status = { id: item.id, state: "error", error: "Job cancelled by user", createdAt: Date.now() };
        this.statuses.set(item.id, status);
        this.onStatus?.(status);
        return;
      }

      const out = await this.process(item.id, item.input);

      // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–º–µ–Ω—ã
      if (this.cancelled.has(item.id)) {
        this.cancelled.delete(item.id);
        status = { id: item.id, state: "error", error: "Job cancelled during finalization", createdAt: Date.now() };
      } else {
        status = { id: item.id, state: "done", output: out.output, srt: out.srt, vtt: out.vtt, createdAt: Date.now() };
        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≤ –∞—Ä—Ö–∏–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö
        this.completed.set(item.id, status);
      }
      
      this.statuses.set(item.id, status);
      this.onStatus?.(status);
      this.statuses.delete(item.id); // –£–¥–∞–ª—è–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    } catch (e: any) {
      const status: JobStatus & { createdAt: number } = { 
        id: item.id, 
        state: "error", 
        error: e?.message || String(e),
        createdAt: Date.now()
      };
      this.statuses.set(item.id, status);
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—à–∏–±–æ—á–Ω—É—é –∑–∞–¥–∞—á—É –≤ –∞—Ä—Ö–∏–≤, —á—Ç–æ–±—ã /api/status –Ω–µ –æ—Ç–¥–∞–≤–∞–ª NOT_FOUND
      this.completed.set(item.id, status);
      this.onStatus?.(status);
      this.statuses.delete(item.id);
    } finally {
      this.running = false;
      this.pump();
    }
  }

  private async process(id: string, input: PlanInput): Promise<{ output: string; srt?: string; vtt?: string }> {
    const workRoot = "/app/output";
    const workDir = path.join(workRoot, `job_${id}`);
    await fse.ensureDir(workDir);

    // 1) –°–±–æ—Ä–∫–∞ —Å–ª–∞–π–¥–æ–≤
    const slidesPath = await buildSlidesVideo(input, workDir);

    // 2) –û–∑–≤—É—á–∫–∞
    let voicePath: string | null = null;
    try {
      voicePath = await resolveVoiceTrack(input, workDir);
    } catch {
      voicePath = null;
    }

    // 3) –°—É–±—Ç–∏—Ç—Ä—ã —á–µ—Ä–µ–∑ Whisper (—Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è –≤–µ—Ä—Å–∏—è)
    let srtPath: string | undefined;
    if (input.transcribeAudio && voicePath) {
      try {
        srtPath = await transcribeWithWhisper(voicePath, workDir, "base");
        console.log(`üé§ Whisper: —Å–æ–∑–¥–∞–Ω ${srtPath}`);
      } catch (e: any) {
        console.error("–û—à–∏–±–∫–∞ Whisper:", e.message);
        throw new Error(`Whisper failed: ${e?.message || e}`);
      }
    }

    // 4) –°–±–æ—Ä–∫–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–æ–ª–∏–∫–∞
    const outPath = path.join(workRoot, `video_${id}.${input.outputFormat}`);
    const args: string[] = ["-y", "-i", slidesPath];

    const hasMusic = !!input.music;
    const hasVoice = !!voicePath;
    if (hasMusic) args.push("-i", path.resolve(input.music!));
    if (hasVoice) args.push("-i", voicePath!);

    // –°—Ç—Ä–æ–∏–º –≤–∏–¥–µ–æ —Ñ–∏–ª—å—Ç—Ä—ã (—ç—Ñ—Ñ–µ–∫—Ç—ã, –æ–≤–µ—Ä–ª–µ–∏, —Å—É–±—Ç–∏—Ç—Ä—ã)
    const { filter: videoFilter, finalLabel: videoFinalLabel, extraInputs } = await buildVideoOverlayFilter(
      input,
      workDir,
      "[0:v]",
      srtPath,
      "ForceStyle=FontSize=32,PrimaryColour=&HFFFFFF,OutlineColour=&H000000,Outline=2,MarginV=300,Bold=1",
      hasMusic ? 1 : 0
    );

    // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤—Ö–æ–¥—ã –¥–ª—è –æ–≤–µ—Ä–ª–µ–µ–≤
    for (const extraInput of extraInputs) {
      const absInput = path.isAbsolute(extraInput)
        ? extraInput
        : path.resolve("/root/media-video-maker_project", extraInput);
      args.push("-i", absInput);
    }

    // –°—Ç—Ä–æ–∏–º –∞—É–¥–∏–æ —Ñ–∏–ª—å—Ç—Ä—ã
    const musicIndex = hasMusic ? 1 : -1;
    const voiceIndex = hasVoice ? (hasMusic ? 2 : 1) : -1;
    
    const { chain: audioChain, finalLabel: audioFinalLabel } = buildAudioFilter({
      hasMusic,
      hasVoice,
      musicVolumeDb: input.musicVolumeDb ?? -6,
      ducking: input.ducking,
      musicInLabel: hasMusic ? `[${musicIndex}:a]` : "",
      voiceInLabel: hasVoice ? `[${voiceIndex}:a]` : "",
    });

    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤–∏–¥–µ–æ –∏ –∞—É–¥–∏–æ —Ñ–∏–ª—å—Ç—Ä—ã
    const allFilters = [];
    if (videoFilter) allFilters.push(videoFilter);
    if (audioChain) allFilters.push(audioChain);
    
    if (allFilters.length > 0) {
      args.push("-filter_complex", allFilters.join(";"));
    }

    // –ú–∞–ø–ø–∏–Ω–≥ –≤–∏–¥–µ–æ
    if (videoFinalLabel) {
      args.push("-map", videoFinalLabel);
    } else {
      args.push("-map", "0:v:0");
    }

    // –ú–∞–ø–ø–∏–Ω–≥ –∞—É–¥–∏–æ
    if (audioFinalLabel) {
      if (audioFinalLabel.includes(":")) {
        args.push("-map", audioFinalLabel);
      } else {
        args.push("-map", `${audioFinalLabel}`);
      }
      args.push("-c:a", "aac", "-b:a", "192k");
    } else if (hasMusic) {
      args.push("-map", `${musicIndex}:a:0`, "-c:a", "aac", "-b:a", "192k");
    }

    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ: –±—ã—Å—Ç—Ä—ã–π –ø—Ä–µ—Å–µ—Ç –¥–ª—è –Ω–∏–∑–∫–∏—Ö —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π
    const isLowRes = ((input.width ?? 0) <= 854) || ((input.height ?? 0) <= 854);
    args.push("-c:v", "libx264", "-pix_fmt", "yuv420p", "-r", String(input.fps));
    args.push("-preset", isLowRes ? "ultrafast" : "veryfast");
    args.push("-crf", isLowRes ? "28" : "26");
    
    // –í—Å–µ–≥–¥–∞ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ 10 —Å–µ–∫—É–Ω–¥
    args.push("-t", "10");
    
    args.push(outPath);

    await runFFmpeg(args, workDir);

    return { output: outPath, srt: srtPath };
  }
}
