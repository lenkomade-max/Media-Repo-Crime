### Проект: Media Video Maker — задачи на исправление и доводку

Контекст:
- Корень проекта (у меня на диске): `/Volumes/Lexar/media-video-maker_server`.
- Серверный код: TypeScript, сборка `tsc`, рантайм Node 18+.
- Основной сервер: `dist/media-server.js` (порт 4123).

Важно для исполнителя:
- Пиши только код. Ничего не устанавливай и не запускай (ни npm, ни Docker, ни curl, ни сервер). Только правки исходников и пояснение, где и что изменено.
- Дай список изменённых файлов и краткое объяснение каждой правки.
- Соблюдай существующий стиль кода и типы.

---

### Диагноз текущих проблем
- Главный блокер: для чтения инфо о видео внутри сервера местами запускается не `ffprobe`, а `ffmpeg`, из‑за чего пайплайн падает на старте (exit code 8). Сам файл валиден, `ffprobe` работает из системы.
- Следующий риск: в графе оверлеев FFmpeg ошибка вида «Invalid stream specifier …» — проблема с лейблами/порядком входов/выходов в `filter_complex`.
- Остальные функции (загрузка по URL, авто‑очистка, upload‑эндпоинт, TTS, субтитры) реализованы; после снятия блокера их нужно проверить, но в этом задании — только привести код в порядок без запуска.

---

### Задачи (конкретные файлы и требования)

1) Унифицировать медиа‑пробу на `ffprobe`
- Файлы:
  - `src/utils/ffprobe.ts` — уже есть `ffprobeJson(filePath)`. Сделать его единственной точкой входа для пробы.
  - `src/pipeline/MediaProcessor.ts` — найти все места, где для пробы вызывается `ffmpeg` (по признакам `-show_format`/`-show_streams`), заменить на вызов `ffprobeJson`.
  - `src/utils/ffmpeg.ts` — убедиться, что в этом модуле нет логики пробы. Если есть, вынести в `ffprobe.ts` и переиспользовать.
- Требования:
  - Не дублировать код пробы. Один хелпер, единый импорт.
  - Явно типизировать минимум возвращаемых полей (интерфейсы для stream/format, без излишней детализации).

2) Починить `filter_complex` для оверлеев
- Файлы:
  - `src/pipeline/OverlayRenderer.ts`
  - `src/pipeline/VideoOverlayRenderer.ts`
- Требования:
  - Корректная нумерация входов `-i` и соответствующие метки `[...]` в цепочке фильтров.
  - Порядок: базовый видеоряд → VHS/эффекты → прочие видеооверлеи → текст/титры.
  - Удалить/исправить несуществующие лейблы; у каждого звена должны быть валидные входы/выходы.
  - Все пути к файлам оверлеев — преобразовывать в абсолютные до формирования аргументов FFmpeg (`path.resolve`).

3) Проверка/доводка логики загрузки по URL и авто‑очистки (без запуска)
- Файлы:
  - `src/pipeline/MediaCreator.ts` — методы `downloadFiles(...)` и `cleanupDownloadedFiles(...)` должны вызываться в `process(...)` до сборки слоёв и после успешного рендера. Убедиться, что после скачивания `src` заменяется на локальный путь.
  - `src/utils/FileDownloader.ts` — без нестандартных опций `fetch` (например, не использовать `timeout` в `RequestInit`). Валидировать URL, безопасные имена файлов.
  - `src/utils/CleanupService.ts` — содержит только логику очистки/уведомлений, без побочных запусков.
  - `src/types/plan.ts` — поддержка `download`, `musicDownload`, и URL в `src`.
- Требования:
  - Чистить только скачанные временные файлы, локальные исходники не трогать.

4) API и эндпоинты — соответствие контракту
- Файл: `src/media-server.ts`
- Требования:
  - Поддержать: `GET /api/ping`, `POST /api/create-video`, `GET /api/status/:id`, `GET /api/jobs`.
  - Ошибки — в JSON с понятными кодами/сообщениями (используется Zod для валидации плана).
  - Не менять порт и базовые пути.

5) Субтитры и стили
- Файл: `src/subtitles/SubtitlesStyler.ts`
- Требования:
  - Корректная строка `force_style` для FFmpeg: цвета в формате `&H00RRGGBB&`, экранирование, кавычки.
  - Поддержать дизайн из документации (размер, цвет, outline, позиция).

6) TTS (Kokoro)
- Файл: `src/audio/TTSService.ts`
- Требования:
  - Возвращать путь к локальному аудиофайлу (mp3/wav), реально используемому в микшере.
  - Без реальных сетевых вызовов — только корректный код.

7) Нормализация путей и кавычки
- Файлы:
  - `src/pipeline/MediaCreator.ts`
  - `src/utils/ffmpeg.ts`
- Требования:
  - До формирования argv FFmpeg — все пути приводить к абсолютным (`path.resolve`).
  - Не полагаться на symlink `assets/main.mp4`; уметь работать с путями с пробелами за счёт раздельных argv.

8) Тестовые JSON (только файлы)
- Файлы:
  - `test_10sec_with_music.json`
  - `test_simple_480p.json`
- Требования:
  - Обновить примеры, избегая привязки к пробелам в именах, или использовать `assets/main.mp4` как ссылку.

---

### Ограничения
- Не запускать команд и не производить установок (npm/Docker/SSH/curl и т.п.)
- Не менять порты/пути API.
- Не удалять рабочие фичи (URL‑загрузка, авто‑очистка, TTS, субтитры).

### Как сдавать результат
1) Дай список изменённых файлов с кратким описанием причины по каждому пункту (1‑2 предложения).
2) Приведи ключевые фрагменты кода (диффы или блоки) в ответе, отмечая файл и место.
3) Укажи, где именно заменил вызовы на `ffprobeJson`, и какое типизированное API вернул.
4) Для оверлеев — приложи итоговый `filter_complex` (или генерацию), чтобы можно было визуально проверить лейблы/порядок.

### Критерии готовности
- Все места пробы используют `ffprobeJson` из `src/utils/ffprobe.ts`.
- Граф оверлеев строится без «Invalid stream specifier …» и имеет валидные метки/порядок.
- Пути нормализуются в абсолютные до вызова FFmpeg; имена с пробелами не ломают пайплайн.
- Тестовые JSON обновлены.


